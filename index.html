<!doctype html>
<html lang="pt-PT">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ver anaglyph sem óculos (L/R)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { margin:0; height:100%; background:#0b0b0b; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .bar{ padding:8px 12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; background:#111; border-bottom:1px solid #222; }
    .bar label{ font-size:13px; color:#ccc; }
    .bar input[type=range]{ width:140px; }
    .btn{ background:#2b6eea; color:#fff; border:0; padding:6px 10px; border-radius:6px; font-weight:600; }
    #wrap{ position:fixed; inset:46px 0 0 0; display:flex; }
    canvas{ width:50vw; height:100%; display:block; background:#000; }
    #left{ border-right:2px solid #333; }
    #divider{ position:fixed; top:46px; bottom:0; left:50%; width:2px; background:#bbb; pointer-events:none; mix-blend-mode:screen; }
    video{ display:none; }
    .hint{ font-size:12px; color:#aaa; margin-left:auto; }
  </style>
</head>
<body>
  <div class="bar">
    <button id="flip" class="btn">Espelhar: OFF</button>
    <label>Zoom <span id="zv">1.00×</span>
      <input id="zoom" type="range" min="1" max="3" step="0.01" value="1">
    </label>
    <label>Offset X <span id="oxv">0</span>px
      <input id="ox" type="range" min="-80" max="80" step="1" value="0">
    </label>
    <label>Brilho <span id="bv">1.00</span>
      <input id="bright" type="range" min="0.5" max="2" step="0.01" value="1">
    </label>
    <label>Gama <span id="gv">1.00</span>
      <input id="gamma" type="range" min="0.5" max="2" step="0.01" value="1">
    </label>
    <span class="hint">Coloca um separador (cartão) ao centro do ecrã; olho E vê esquerda, olho D vê direita.</span>
  </div>

  <div id="wrap">
    <canvas id="left"></canvas>
    <canvas id="right"></canvas>
    <div id="divider"></div>
  </div>

  <video id="video" autoplay playsinline></video>

<script>
(async function(){
  const video = document.getElementById('video');
  const left = document.getElementById('left');
  const right = document.getElementById('right');
  const lctx = left.getContext('2d', { willReadFrequently:true });
  const rctx = right.getContext('2d', { willReadFrequently:true });

  const zoom = document.getElementById('zoom');
  const zv = document.getElementById('zv');
  const ox = document.getElementById('ox');
  const oxv = document.getElementById('oxv');
  const bright = document.getElementById('bright');
  const bv = document.getElementById('bv');
  const gamma = document.getElementById('gamma');
  const gv = document.getElementById('gv');
  const flipBtn = document.getElementById('flip');

  let mirror = false;

  function fitCanvases(){
    const w = Math.floor(window.innerWidth/2);
    const h = window.innerHeight - document.querySelector('.bar').offsetHeight;
    [left, right].forEach(c => { c.width = w; c.height = h; });
  }
  fitCanvases();
  addEventListener('resize', fitCanvases);

  flipBtn.onclick = () => {
    mirror = !mirror;
    flipBtn.textContent = `Espelhar: ${mirror ? 'ON' : 'OFF'}`;
  };
  zoom.oninput = ()=> zv.textContent = `${(+zoom.value).toFixed(2)}×`;
  ox.oninput = ()=> oxv.textContent = `${ox.value}`;
  bright.oninput = ()=> bv.textContent = `${(+bright.value).toFixed(2)}`;
  gamma.oninput = ()=> gv.textContent = `${(+gamma.value).toFixed(2)}`;

  // pedir câmara traseira
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal:1080 } },
      audio: false
    });
    video.srcObject = stream;
  }catch(e){
    alert('Erro a aceder à câmara. Usa HTTPS (ou localhost) e permite a permissão.');
    console.error(e);
    return;
  }
  await new Promise(r => video.onloadedmetadata = r);

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function applyGamma(v, g){ return 255 * Math.pow(v/255, 1/g); }

  function draw(){
    const lw = left.width, lh = left.height;
    const rw = right.width, rh = right.height;

    // calcular área de captura do vídeo (manter proporção)
    const z = Number(zoom.value);
    const srcW = Math.floor(Math.min(video.videoWidth, video.videoWidth / z));
    const srcH = Math.floor(Math.min(video.videoHeight, video.videoHeight / z));
    const cx = Math.floor((video.videoWidth - srcW)/2 + Number(ox.value));
    const cy = Math.floor((video.videoHeight - srcH)/2);

    // desenhar frame base temporário num offscreen
    // (usamos o próprio left como buffer de leitura para evitar alocar offscreen extra)
    lctx.drawImage(video, cx, cy, srcW, srcH, 0, 0, lw, lh);
    const frame = lctx.getImageData(0,0,lw,lh);
    const data = frame.data;

    // Buffers de saída para cada olho
    const L = new Uint8ClampedArray(data.length);
    const R = new Uint8ClampedArray(data.length);

    const br = Number(bright.value);
    const gm = Number(gamma.value);

    // Decodificação anaglyph:
    // - OLHO ESQUERDO: canal R (vermelho) -> luminância
    // - OLHO DIREITO: canais G e B (ciano) -> luminância
    for(let i=0; i<data.length; i+=4){
      const r = data[i];
      const g = data[i+1];
      const b = data[i+2];

      // luminâncias simples (rápidas). Opcionalmente, podes usar ponderações.
      let leftY  = r;          // do canal vermelho
      let rightY = (g + b)/2;  // do canal ciano

      // brilho e gama
      leftY  = clamp(applyGamma(leftY * br, gm), 0, 255);
      rightY = clamp(applyGamma(rightY * br, gm), 0, 255);

      // saída grayscale para cada olho
      L[i] = L[i+1] = L[i+2] = leftY;  L[i+3] = 255;
      R[i] = R[i+1] = R[i+2] = rightY; R[i+3] = 255;
    }

    // pintar em cada canvas
    const limg = new ImageData(L, lw, lh);
    const rimg = new ImageData(R, rw, rh);

    if(mirror){
      // espelhar horizontalmente (útil consoante a forma como seguras o telefone)
      lctx.save(); lctx.scale(-1,1); lctx.putImageData(limg, -lw, 0); lctx.restore();
      rctx.save(); rctx.scale(-1,1); rctx.putImageData(rimg, -rw, 0); rctx.restore();
    }else{
      lctx.putImageData(limg, 0, 0);
      rctx.putImageData(rimg, 0, 0);
    }

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
